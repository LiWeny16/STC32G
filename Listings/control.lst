C251 COMPILER V5.60.0,  control                                                            22/03/23  18:05:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\Out\control.obj
COMPILER INVOKED BY: C:\Learning\Keil_v5\body\C251\BIN\C251.EXE User\User_c\control.c XSMALL INTR2 BROWSE INCDIR(.\Lib\l
                    -ibraries;.\Lib\seekfree_libraries;.\Lib\seekfree_peripheral;.\User\User_h) DEBUG PRINT(.\Listings\control.lst) TABS(2) O
                    -BJECT(.\Out\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          
    3          void Control_All()
    4          {
    5   1      
    6   1        // 以下为舵机驱动部分
    7   1        calculate_s(&dg_state, &err_steering); // 计算偏差值，写电感
    8   1      
    9   1        road = road_judge(&road_flag,&dg_state,&err_steering); // 根据电感结构体判断道路状况返回道路结构体
   10   1      
   11   1        Pid_Steering_Calculate(road, &err_steering, &pid_steering); // 计算pid输出值，并写入实参
   12   1        STEERING_Control(road, &pid_steering);            // 从pid输出到实际舵机驱动,判断道路结构体，并做出响应
   13   1      
   14   1        // 以下为电机驱动部分
   15   1        // 速度选择
   16   1        speedout(road, &speed_now, &speed_state);  // 根据道路情况将速度状态结构体中的一组设定值赋给当前速度结构
             -体中的目标值
   17   1        speed_cal(&speed_now);             // 根据编码器数据计算速度值，并将其赋给当前速度结构体中的当前速度值
   18   1        calculate_err_m(&speed_now, &err_motor);   // 根据编码器数值计算偏差值，并更新偏差值结构体中last量,结果保
             -存在电机偏差值结构体中
   19   1        Pid_Motor_Calculate(&err_motor, &pid_motor); // 由电机偏差（由编码器反应）结构体计算电机PID输出增量
   20   1        MOTOR_Control(road, &pid_motor);       // 从pid输出到实际电机驱动
   21   1      }
   22          
   23          void STEERING_Control(Road road, PID_Steering *pid_steering)
   24          {
   25   1        // temp = pid_steering->PID_STEERING_OUT;
   26   1        // pid_steering->PID_STEERING_OUT=(pid_steering->PID_STEERING_OUT+725.0); //之前有正负
   27   1        switch (road)
   28   1        {
   29   2        case (Straight): // 直道
   30   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + 725.0;
   31   2          // temp=(temp+725.0); //之前有正负，是PID权重后的值
   32   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   33   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));                                     // 舵机驱动
   34   2          break;
   35   2        case (Curve_Left):
   36   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + 725.0;
   37   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   38   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));
   39   2          break;
   40   2        case (Curve_Right):
   41   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + 725.0;
   42   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   43   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));
   44   2          break;
   45   2      
   46   2        case (Ring_In):
   47   2          pwm_duty(STEERING, 800); //左转打死
   48   2          break;
   49   2        case (Ring_Out):
   50   2          pwm_duty(STEERING, 800); //左转打死
   51   2          break;
   52   2        case (Stop): // 停下
C251 COMPILER V5.60.0,  control                                                            22/03/23  18:05:14  PAGE 2   

   53   2          pwm_duty(STEERING, 725);
   54   2          break;
   55   2      
   56   2        default: // 别的
   57   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + 725.0;
   58   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   59   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));   
   60   2          break;
   61   2        }
   62   1      }
   63          
   64          void MOTOR_Control(Road road, PID_Motor *pid_motor)
   65          {
   66   1        switch (road)
   67   1        {
   68   2        case (Straight): // 直道
   69   2          pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
   70   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
   71   2      
   72   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
   73   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
   74   2      
   75   2          // pwm_duty(MOTOR1_P,pid_motor->PID_MOTOR_L_OUT);//左电机驱动
   76   2          // pwm_duty(MOTOR1_N,pid_motor->PID_MOTOR_L_OUT);
   77   2          // pwm_duty(PWMA_CH1P_P60,(uint32)0);//左电机驱动
   78   2          // pwm_duty(PWMA_CH2P_P62,pid_motor->PID_MOTOR_L_OUT/5);
   79   2          // 15000 对应占空比1400
   80   2          pwm_duty(PWMA_CH1P_P60, pid_motor->PID_MOTOR_L_OUT); // 左电机驱动
   81   2          pwm_duty(PWMA_CH2P_P62, pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
   82   2      
   83   2          pwm_duty(PWMA_CH3P_P64, pid_motor->PID_MOTOR_R_OUT); // 右电机驱动
   84   2          pwm_duty(PWMA_CH4P_P66, pid_motor->PID_MOTOR_R_OUT);
   85   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
   86   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
   87   2          break;
   88   2      
   89   2        case (Curve_Left): //左转
   90   2              pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
   91   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
   92   2      
   93   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
   94   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
   95   2      
   96   2          pwm_duty(PWMA_CH1P_P60, pid_motor->PID_MOTOR_L_OUT); // 左电机驱动
   97   2          pwm_duty(PWMA_CH2P_P62, pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
   98   2      
   99   2          pwm_duty(PWMA_CH3P_P64, pid_motor->PID_MOTOR_R_OUT); // 右电机驱动
  100   2          pwm_duty(PWMA_CH4P_P66, pid_motor->PID_MOTOR_R_OUT);
  101   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
  102   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
  103   2          break;
  104   2        case (Curve_Right): //右转
  105   2              pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
  106   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
  107   2      
  108   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
  109   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
  110   2      
  111   2          pwm_duty(PWMA_CH1P_P60, pid_motor->PID_MOTOR_L_OUT); // 左电机驱动
  112   2          pwm_duty(PWMA_CH2P_P62, pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
  113   2      
  114   2          pwm_duty(PWMA_CH3P_P64, pid_motor->PID_MOTOR_R_OUT); // 右电机驱动
C251 COMPILER V5.60.0,  control                                                            22/03/23  18:05:14  PAGE 3   

  115   2          pwm_duty(PWMA_CH4P_P66, pid_motor->PID_MOTOR_R_OUT);
  116   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
  117   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
  118   2          break;
  119   2        case (Stop):          // 停下
  120   2          pwm_duty(PWMA_CH1P_P60, 0); // 左电机驱动
  121   2          pwm_duty(PWMA_CH2P_P62, 0); // 单独它一个有数值，反转
  122   2      
  123   2          pwm_duty(PWMA_CH3P_P64, 0); // 右电机驱动
  124   2          pwm_duty(PWMA_CH4P_P66, 0);
  125   2          break;
  126   2      
  127   2        default: // 别的
  128   2          pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
  129   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
  130   2      
  131   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
  132   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
  133   2      
  134   2          pwm_duty(PWMA_CH1P_P60, pid_motor->PID_MOTOR_L_OUT); // 左电机驱动
  135   2          pwm_duty(PWMA_CH2P_P62, pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
  136   2      
  137   2          pwm_duty(PWMA_CH3P_P64, pid_motor->PID_MOTOR_R_OUT); // 右电机驱动
  138   2          pwm_duty(PWMA_CH4P_P66, pid_motor->PID_MOTOR_R_OUT);
  139   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
  140   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
  141   2          break;
  142   2        }
  143   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       570     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
