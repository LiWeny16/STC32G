C251 COMPILER V5.60.0,  control                                                            04/04/23  11:50:07  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\Out\control.obj
COMPILER INVOKED BY: C:\Learning\Keil_v5\body\C251\BIN\C251.EXE User\User_c\control.c XSMALL INTR2 BROWSE INCDIR(.\Lib\l
                    -ibraries;.\Lib\seekfree_libraries;.\Lib\seekfree_peripheral;.\User\User_h) DEBUG PRINT(.\Listings\control.lst) TABS(2) O
                    -BJECT(.\Out\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          
    3          void Control_All()
    4          {
    5   1      
    6   1        // ÒÔÏÂÎª¶æ»úÇý¶¯²¿·Ö
    7   1        calculate_s(&dg_state, &err_steering); // ¼ÆËãÆ«²îÖµ£¬Ð´µç¸Ð
    8   1      
    9   1        road = road_judge(&timer,&road_flag,&dg_state,&err_steering); // ¸ù¾Ýµç¸Ð½á¹¹ÌåÅÐ¶ÏµÀÂ·×´¿ö·µ»ØµÀÂ·½á¹¹Ì
             -å
   10   1      
   11   1        Pid_Steering_Calculate(road, &err_steering, &pid_steering); // ¼ÆËãpidÊä³öÖµ£¬²¢Ð´ÈëÊµ²Î
   12   1        STEERING_Control(road, &pid_steering);            // ´ÓpidÊä³öµ½Êµ¼Ê¶æ»úÇý¶¯,ÅÐ¶ÏµÀÂ·½á¹¹Ìå£¬²¢×ö³öÏìÓ¦
   13   1      
   14   1        // ÒÔÏÂÎªµç»úÇý¶¯²¿·Ö
   15   1        // ËÙ¶ÈÑ¡Ôñ
   16   1        speedout(road, &speed_now, &speed_state);  // ¸ù¾ÝµÀÂ·Çé¿ö½«ËÙ¶È×´Ì¬½á¹¹ÌåÖÐµÄÒ»×éÉè¶¨Öµ¸³¸øµ±Ç°ËÙ¶È½á¹¹
             -ÌåÖÐµÄÄ¿±êÖµ
   17   1        speed_cal(&speed_now);             // ¸ù¾Ý±àÂëÆ÷Êý¾Ý¼ÆËãËÙ¶ÈÖµ£¬²¢½«Æä¸³¸øµ±Ç°ËÙ¶È½á¹¹ÌåÖÐµÄµ±Ç°ËÙ¶ÈÖµ
   18   1        calculate_err_m(&speed_now, &err_motor);   // ¸ù¾Ý±àÂëÆ÷ÊýÖµ¼ÆËãÆ«²îÖµ£¬²¢¸üÐÂÆ«²îÖµ½á¹¹ÌåÖÐlastÁ¿,½á¹û±£
             -´æÔÚµç»úÆ«²îÖµ½á¹¹ÌåÖÐ
   19   1        Pid_Motor_Calculate(&err_motor, &pid_motor); // ÓÉµç»úÆ«²î£¨ÓÉ±àÂëÆ÷·´Ó¦£©½á¹¹Ìå¼ÆËãµç»úPIDÊä³öÔöÁ¿
   20   1        MOTOR_Control(road, &pid_motor);       // ´ÓpidÊä³öµ½Êµ¼Êµç»úÇý¶¯
   21   1      }
   22          
   23          void STEERING_Control(Road road, PID_Steering *pid_steering)
   24          {
   25   1        // temp = pid_steering->PID_STEERING_OUT;
   26   1        // pid_steering->PID_STEERING_OUT=(pid_steering->PID_STEERING_OUT+725.0); //Ö®Ç°ÓÐÕý¸º
   27   1        float Steer_center_temp = 735.0;
   28   1        switch (road)
   29   1        {
   30   2        case (Straight): // Ö±µÀ
   31   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   32   2          // temp=(temp+725.0); //Ö®Ç°ÓÐÕý¸º£¬ÊÇPIDÈ¨ÖØºóµÄÖµ
   33   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // Çý¶¯ÏÞ·ù
   34   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));                                     // ¶æ»úÇý¶¯
   35   2          break;
   36   2        case (Curve_Left):
   37   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   38   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // Çý¶¯ÏÞ·ù
   39   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));
   40   2          break;
   41   2        case (Curve_Right):
   42   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   43   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // Çý¶¯ÏÞ·ù
   44   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));
   45   2          break;
   46   2      
   47   2        case (Ring_In):
   48   2          pwm_duty(STEERING, 800); //×ó×ª´òËÀ
   49   2          break;
   50   2        case (Ring_Out):
   51   2          pwm_duty(STEERING, 800); //×ó×ª´òËÀ
C251 COMPILER V5.60.0,  control                                                            04/04/23  11:50:07  PAGE 2   

   52   2          break;
   53   2        case (Stop): // Í£ÏÂ
   54   2          pwm_duty(STEERING, Steer_center_temp);
   55   2          break;
   56   2      
   57   2        default: // ±ðµÄ
   58   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   59   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // Çý¶¯ÏÞ·ù
   60   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));   
   61   2          break;
   62   2        }
   63   1      }
   64          
   65          void MOTOR_Control(Road road, PID_Motor *pid_motor)
   66          {
   67   1        switch (road)
   68   1        {
   69   2        case (Straight): // Ö±µÀ
   70   2          pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
   71   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
   72   2      
   73   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // Çý¶¯ÏÞ·ù
   74   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
   75   2      
   76   2          // pwm_duty(MOTOR1_P,pid_motor->PID_MOTOR_L_OUT);//×óµç»úÇý¶¯
   77   2          // pwm_duty(MOTOR1_N,pid_motor->PID_MOTOR_L_OUT);
   78   2          // pwm_duty(PWMA_CH1P_P60,(uint32)0);//×óµç»úÇý¶¯
   79   2          // pwm_duty(PWMA_CH2P_P62,pid_motor->PID_MOTOR_L_OUT/5);
   80   2          // 15000 ¶ÔÓ¦Õ¼¿Õ±È1400
   81   2          pwm_duty(L_Motor_P, 0); // ×óµç»úÇý¶¯
   82   2          pwm_duty(L_Motor_N, 5000+pid_motor->PID_MOTOR_L_OUT); // µ¥¶ÀËüÒ»¸öÓÐÊýÖµ£¬·´×ª
   83   2      
   84   2          pwm_duty(R_Motor_P, 0); // ÓÒµç»úÇý¶¯
   85   2          pwm_duty(R_Motor_N, 5000+pid_motor->PID_MOTOR_R_OUT);
   86   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // ×óµç»úPWM¸üÐÂ
   87   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // ÓÒµç»úPWM¸üÐÂ
   88   2          break;
   89   2      
   90   2        case (Curve_Left): //×ó×ª
   91   2              pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
   92   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
   93   2      
   94   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // Çý¶¯ÏÞ·ù
   95   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
   96   2      
   97   2          pwm_duty(L_Motor_P, 0); // ×óµç»úÇý¶¯
   98   2          pwm_duty(L_Motor_N,5000+ pid_motor->PID_MOTOR_L_OUT); // µ¥¶ÀËüÒ»¸öÓÐÊýÖµ£¬·´×ª
   99   2      
  100   2          pwm_duty(R_Motor_P, 0); // ÓÒµç»úÇý¶¯
  101   2          pwm_duty(R_Motor_N,5000+ pid_motor->PID_MOTOR_R_OUT);
  102   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // ×óµç»úPWM¸üÐÂ
  103   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // ÓÒµç»úPWM¸üÐÂ
  104   2          break;
  105   2        case (Curve_Right): //ÓÒ×ª
  106   2              pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
  107   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
  108   2      
  109   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // Çý¶¯ÏÞ·ù
  110   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
  111   2      
  112   2          pwm_duty(L_Motor_P, 0); // ×óµç»úÇý¶¯
  113   2          pwm_duty(L_Motor_N,5000+ pid_motor->PID_MOTOR_L_OUT); // µ¥¶ÀËüÒ»¸öÓÐÊýÖµ£¬·´×ª
C251 COMPILER V5.60.0,  control                                                            04/04/23  11:50:07  PAGE 3   

  114   2      
  115   2          pwm_duty(R_Motor_P,0); // ÓÒµç»úÇý¶¯
  116   2          pwm_duty(R_Motor_N,5000+ pid_motor->PID_MOTOR_R_OUT);
  117   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // ×óµç»úPWM¸üÐÂ
  118   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // ÓÒµç»úPWM¸üÐÂ
  119   2          break;
  120   2        case (Stop):          // Í£ÏÂ
  121   2          pwm_duty(L_Motor_P, 0); // ×óµç»úÇý¶¯
  122   2          pwm_duty(L_Motor_N, 5000); // µ¥¶ÀËüÒ»¸öÓÐÊýÖµ£¬·´×ª
  123   2      
  124   2          pwm_duty(R_Motor_P, 0); // ÓÒµç»úÇý¶¯
  125   2          pwm_duty(R_Motor_N, 5000);
  126   2          break;
  127   2      
  128   2        default: // ±ðµÄ
  129   2          pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
  130   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
  131   2      
  132   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // Çý¶¯ÏÞ·ù
  133   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
  134   2      
  135   2          pwm_duty(L_Motor_P,0); // ×óµç»úÇý¶¯
  136   2          pwm_duty(L_Motor_N,5000+ pid_motor->PID_MOTOR_L_OUT); // µ¥¶ÀËüÒ»¸öÓÐÊýÖµ£¬·´×ª
  137   2      
  138   2          pwm_duty(R_Motor_P,0); // ÓÒµç»úÇý¶¯
  139   2          pwm_duty(R_Motor_N,5000+ pid_motor->PID_MOTOR_R_OUT);
  140   2          PWM_Motor_L_now =  pid_motor->PID_MOTOR_L_OUT; // ×óµç»úPWM¸üÐÂ
  141   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // ÓÒµç»úPWM¸üÐÂ
  142   2          break;
  143   2        }
  144   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       578     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
