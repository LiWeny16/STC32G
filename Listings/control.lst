C251 COMPILER V5.60.0,  control                                                            31/03/23  21:15:39  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\Out\control.obj
COMPILER INVOKED BY: C:\Learning\Keil_v5\body\C251\BIN\C251.EXE User\User_c\control.c XSMALL INTR2 BROWSE INCDIR(.\Lib\l
                    -ibraries;.\Lib\seekfree_libraries;.\Lib\seekfree_peripheral;.\User\User_h) DEBUG PRINT(.\Listings\control.lst) TABS(2) O
                    -BJECT(.\Out\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          
    3          void Control_All()
    4          {
    5   1      
    6   1        // 以下为舵机驱动部分
    7   1        calculate_s(&dg_state, &err_steering); // 计算偏差值，写电感
    8   1      
    9   1        road = road_judge(&road_flag,&dg_state,&err_steering); // 根据电感结构体判断道路状况返回道路结构体
   10   1      
   11   1        Pid_Steering_Calculate(road, &err_steering, &pid_steering); // 计算pid输出值，并写入实参
   12   1        STEERING_Control(road, &pid_steering);            // 从pid输出到实际舵机驱动,判断道路结构体，并做出响应
   13   1      
   14   1        // 以下为电机驱动部分
   15   1        // 速度选择
   16   1        speedout(road, &speed_now, &speed_state);  // 根据道路情况将速度状态结构体中的一组设定值赋给当前速度结构
             -体中的目标值
   17   1        speed_cal(&speed_now);             // 根据编码器数据计算速度值，并将其赋给当前速度结构体中的当前速度值
   18   1        calculate_err_m(&speed_now, &err_motor);   // 根据编码器数值计算偏差值，并更新偏差值结构体中last量,结果保
             -存在电机偏差值结构体中
   19   1        Pid_Motor_Calculate(&err_motor, &pid_motor); // 由电机偏差（由编码器反应）结构体计算电机PID输出增量
   20   1        MOTOR_Control(road, &pid_motor);       // 从pid输出到实际电机驱动
   21   1      }
   22          
   23          void STEERING_Control(Road road, PID_Steering *pid_steering)
   24          {
   25   1        // temp = pid_steering->PID_STEERING_OUT;
   26   1        // pid_steering->PID_STEERING_OUT=(pid_steering->PID_STEERING_OUT+725.0); //之前有正负
   27   1        float Steer_center_temp = 740.0;
   28   1        switch (road)
   29   1        {
   30   2        case (Straight): // 直道
   31   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   32   2          // temp=(temp+725.0); //之前有正负，是PID权重后的值
   33   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   34   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));                                     // 舵机驱动
   35   2          break;
   36   2        case (Curve_Left):
   37   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   38   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   39   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));
   40   2          break;
   41   2        case (Curve_Right):
   42   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   43   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   44   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));
   45   2          break;
   46   2      
   47   2        case (Ring_In):
   48   2          pwm_duty(STEERING, 800); //左转打死
   49   2          break;
   50   2        case (Ring_Out):
   51   2          pwm_duty(STEERING, 800); //左转打死
   52   2          break;
C251 COMPILER V5.60.0,  control                                                            31/03/23  21:15:39  PAGE 2   

   53   2        case (Stop): // 停下
   54   2          pwm_duty(STEERING, Steer_center_temp);
   55   2          break;
   56   2      
   57   2        default: // 别的
   58   2          pid_steering->STEERING_OUT_temp = pid_steering->STEERING_OUT_temp + Steer_center_temp;
   59   2          pid_steering->PID_STEERING_OUT = constrain_uint32((uint32)pid_steering->STEERING_OUT_temp, PWM_Steering
             -_Min, PWM_Steering_Max); // 驱动限幅
   60   2          pwm_duty(STEERING, (pid_steering->PID_STEERING_OUT));   
   61   2          break;
   62   2        }
   63   1      }
   64          
   65          void MOTOR_Control(Road road, PID_Motor *pid_motor)
   66          {
   67   1        switch (road)
   68   1        {
   69   2        case (Straight): // 直道
   70   2          pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
   71   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
   72   2      
   73   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
   74   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
   75   2      
   76   2          // pwm_duty(MOTOR1_P,pid_motor->PID_MOTOR_L_OUT);//左电机驱动
   77   2          // pwm_duty(MOTOR1_N,pid_motor->PID_MOTOR_L_OUT);
   78   2          // pwm_duty(PWMA_CH1P_P60,(uint32)0);//左电机驱动
   79   2          // pwm_duty(PWMA_CH2P_P62,pid_motor->PID_MOTOR_L_OUT/5);
   80   2          // 15000 对应占空比1400
   81   2          pwm_duty(L_Motor_P, 0); // 左电机驱动
   82   2          pwm_duty(L_Motor_N, 5000+pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
   83   2      
   84   2          pwm_duty(R_Motor_P, 0); // 右电机驱动
   85   2          pwm_duty(R_Motor_N, 5000+pid_motor->PID_MOTOR_R_OUT);
   86   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
   87   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
   88   2          break;
   89   2      
   90   2        case (Curve_Left): //左转
   91   2              pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
   92   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
   93   2      
   94   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
   95   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
   96   2      
   97   2          pwm_duty(L_Motor_P, 0); // 左电机驱动
   98   2          pwm_duty(L_Motor_N,5000+ pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
   99   2      
  100   2          pwm_duty(R_Motor_P, 0); // 右电机驱动
  101   2          pwm_duty(R_Motor_N,5000+ pid_motor->PID_MOTOR_R_OUT);
  102   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
  103   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
  104   2          break;
  105   2        case (Curve_Right): //右转
  106   2              pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
  107   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
  108   2      
  109   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
  110   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
  111   2      
  112   2          pwm_duty(L_Motor_P, 0); // 左电机驱动
  113   2          pwm_duty(L_Motor_N,5000+ pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
  114   2      
C251 COMPILER V5.60.0,  control                                                            31/03/23  21:15:39  PAGE 3   

  115   2          pwm_duty(R_Motor_P,0); // 右电机驱动
  116   2          pwm_duty(R_Motor_N,5000+ pid_motor->PID_MOTOR_R_OUT);
  117   2          PWM_Motor_L_now = pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
  118   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
  119   2          break;
  120   2        case (Stop):          // 停下
  121   2          pwm_duty(L_Motor_P, 0); // 左电机驱动
  122   2          pwm_duty(L_Motor_N, 5000); // 单独它一个有数值，反转
  123   2      
  124   2          pwm_duty(R_Motor_P, 0); // 右电机驱动
  125   2          pwm_duty(R_Motor_N, 5000);
  126   2          break;
  127   2      
  128   2        default: // 别的
  129   2          pid_motor->PID_MOTOR_L_OUT = pid_motor->PID_MOTOR_L_OUT + PWM_Motor_L_now;
  130   2          pid_motor->PID_MOTOR_R_OUT = pid_motor->PID_MOTOR_R_OUT + PWM_Motor_R_now;
  131   2      
  132   2          pid_motor->PID_MOTOR_L_OUT = constrain_float(pid_motor->PID_MOTOR_L_OUT, PWM_Motor_Min, PWM_Motor_Max);
             - // 驱动限幅
  133   2          pid_motor->PID_MOTOR_R_OUT = constrain_float(pid_motor->PID_MOTOR_R_OUT, PWM_Motor_Min, PWM_Motor_Max);
  134   2      
  135   2          pwm_duty(L_Motor_P,0); // 左电机驱动
  136   2          pwm_duty(L_Motor_N,5000+ pid_motor->PID_MOTOR_L_OUT); // 单独它一个有数值，反转
  137   2      
  138   2          pwm_duty(R_Motor_P,0); // 右电机驱动
  139   2          pwm_duty(R_Motor_N,5000+ pid_motor->PID_MOTOR_R_OUT);
  140   2          PWM_Motor_L_now =  pid_motor->PID_MOTOR_L_OUT; // 左电机PWM更新
  141   2          PWM_Motor_R_now = pid_motor->PID_MOTOR_R_OUT; // 右电机PWM更新
  142   2          break;
  143   2        }
  144   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       568     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
