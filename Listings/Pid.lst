C251 COMPILER V5.60.0,  Pid                                                                06/04/23  00:08:04  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Pid
OBJECT MODULE PLACED IN .\Out\Pid.obj
COMPILER INVOKED BY: C:\Learning\Keil_v5\body\C251\BIN\C251.EXE User\User_c\Pid.c XSMALL INTR2 BROWSE INCDIR(.\Lib\libra
                    -ries;.\Lib\seekfree_libraries;.\Lib\seekfree_peripheral;.\User\User_h) DEBUG PRINT(.\Listings\Pid.lst) TABS(2) OBJECT(.\
                    -Out\Pid.obj) 

stmt  level    source

    1          // 该文件用于使用舵机偏差结构体和电机偏差结构体计算舵机PID输出值和电机PID增量值
    2          
    3          #include "Pid.h"
    4          float constrain_float(float amt, float low, float high) // 限幅用，low和high为上下限
    5          {
    6   1        return ((amt) < (low) ? (low) : ((amt) > (high) ? (high) : (amt)));
    7   1      }
    8          
    9          uint32 constrain_uint32(uint32 amt, uint32 low, uint32 high) // 限幅用，low和high为上下限
   10          {
   11   1        return ((amt) < (low) ? (low) : ((amt) > (high) ? (high) : (amt)));
   12   1      }
   13          
   14          int32 constrain_int32(int32 amt, int32 low, int32 high) // 限幅用，low和high为上下限
   15          {
   16   1        return ((amt) < (low) ? (low) : ((amt) > (high) ? (high) : (amt)));
   17   1      }
   18          
   19          void Pid_Steering_Calculate(Road road, volatile Err_Steering *err_steering, volatile PID_Steering *pid_st
             -eering) // 舵机位置式PID输出值
   20          {
   21   1      
   22   1        //   constrain_float(err_steering->Errsum, pid_steering->imax, pid_steering->imin);
   23   1        // 位置式PID积分项限幅
   24   1        float p_Curve_L;
   25   1        float i_Curve_L;
   26   1        float d_Curve_L;
   27   1      
   28   1        float p_Curve_R;
   29   1        float i_Curve_R;
   30   1        float d_Curve_R;
   31   1        
   32   1        p_Curve_L = 20.5;
   33   1        i_Curve_L = 0;
   34   1        d_Curve_L = 4.5;
   35   1      
   36   1        p_Curve_R = 20.5;
   37   1        i_Curve_R = 0;
   38   1        d_Curve_R = 4.5;
   39   1        switch (road)
   40   1        {
   41   2        case (Straight): // 直道
   42   2          err_steering->Err=(0.4151 * (err_steering->Err_x)) + (3.4868 * (err_steering->Err_h));
   43   2          pid_steering->STEERING_OUT_temp = (float)((pid_steering->p_steering * (err_steering->Err)) + (pid_steer
             -ing->i_steering * err_steering->Errsum) + (pid_steering->d_steering * err_steering->Errdif));
   44   2          break;
   45   2      
   46   2        case (Curve_Left): // 弯道
   47   2          err_steering->Err=(1.1151 * (err_steering->Err_x)) + (4.5868 * (err_steering->Err_h));
   48   2          pid_steering->STEERING_OUT_temp = (float)((p_Curve_L * err_steering->Err) + (i_Curve_L * err_steering->
             -Errsum) + (d_Curve_L * err_steering->Errdif));
   49   2          break;
   50   2      
   51   2        case (Curve_Right): // 弯道
   52   2          err_steering->Err=(1.1151 * (err_steering->Err_x)) + (4.5868 * (err_steering->Err_h));
   53   2          pid_steering->STEERING_OUT_temp = (float)((p_Curve_R * err_steering->Err) + (i_Curve_R * err_steering->
             -Errsum) + (d_Curve_R * err_steering->Errdif));
C251 COMPILER V5.60.0,  Pid                                                                06/04/23  00:08:04  PAGE 2   

   54   2          break;
   55   2        case (Big_Ring):
   56   2          err_steering->Err=(1.1151 * (err_steering->Err_x)) + (4.5868 * (err_steering->Err_h));
   57   2          pid_steering->STEERING_OUT_temp = (float)((p_Curve_R * err_steering->Err) + (i_Curve_R * err_steering->
             -Errsum) + (d_Curve_R * err_steering->Errdif));
   58   2          break;
   59   2        
   60   2        case (Stop):
   61   2          pid_steering->STEERING_OUT_temp = 0;
   62   2        default: // 别的
   63   2          pid_steering->STEERING_OUT_temp = (float)((pid_steering->p_steering * err_steering->Err) + (pid_steerin
             -g->i_steering * err_steering->Errsum) + (pid_steering->d_steering * err_steering->Errdif));
   64   2          break;
   65   2        }
   66   1      
   67   1        // tempVar =(float)((pid_steering->p_steering * err_steering-> Err) + (pid_steering->i_steering * err_st
             -eering-> Errsum) + (pid_steering->d_steering * err_steering-> Errdif));
   68   1        // pid_steering->PID_STEERING_OUT = (f)(((pid_steering->p_steering * err_steering-> Err*(-1.0)) + (pid_s
             -teering->i_steering * err_steering-> Errsum*0) + (pid_steering->d_steering * err_steering-> Errdif)*0));
   69   1        //  temp =   pid_steering->PID_STEERING_OUT
   70   1        // 位置式PID输出计算
   71   1      }
   72          
   73          void Pid_Motor_Calculate(Err_Motor *err_motor, PID_Motor *pid_motor) // 电机增量式PID输出增量
   74          {
   75   1        pid_motor->MOTOR_L_OUT_temp= (pid_motor->p_motor * err_motor->err_derivative_L_m) + (pid_motor->i_motor 
             -* err_motor->err_L_m) + (pid_motor->d_motor * err_motor->err_derivative2_L_m);
   76   1        pid_motor->MOTOR_R_OUT_temp = (pid_motor->p_motor * err_motor->err_derivative_R_m) + (pid_motor->i_motor
             - * err_motor->err_R_m) + (pid_motor->d_motor * err_motor->err_derivative2_R_m);
   77   1      
   78   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       571     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------         16
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
